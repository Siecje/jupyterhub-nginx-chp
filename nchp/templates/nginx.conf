# Let nginx automatically determine the number of worker processes
# to run. This defaults to number of cores on the host.
worker_processes auto;

# Do not daemonize - we'll either run this under a supervisor
# ourselves, or jupyterhub will manage the process, restarting
# it when it dies as necessary
daemon off;

# Set number of connections accepted per worker
events {
    worker_connections 768;
}

# This needs to be in 'main' since otherwise nginx
# will try to write to /var/log/nginx/error.log and failed
# because it does not have permissions
error_log stderr warn;

# We do not really need / care about a pidfile
pid /dev/null;

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    # server_tokens off;

    # These are varilous temp file paths, many that we do not use.
    # They are by default set to /var/lib/nginx/*, which causes
    # problems when running as non-root, as we are here. So we
    # shall set them all to /tmp. FIXME: Find proper paths for
    # these somewhere (perhaps on current-dir?)
    client_body_temp_path /tmp;
    proxy_temp_path /tmp;
    fastcgi_temp_path /tmp;
    uwsgi_temp_path /tmp;
    scgi_temp_path /tmp;

    # access_log does not support 'stderr' directive directly
    # FIXME: This does not work in docker < 1.9 https://github.com/docker/docker/issues/6880
    access_log /dev/stderr;

    # nginx needs an async way to resolve hostnames to IPs, and
    # the default `gethostbyname` setup does not allow for this.
    # While ideally nginx should parse /etc/resolv.conf itself,
    # it does not do so at this time, and needs us to set the DNS
    # server explicitly. This can be specified by the user, but
    # defaults to a value we parse out of /etc/resolv.conf.
    # NOTE: This causes issues when resolving `localhost` and
    # other hostnames traditionally set in /etc/hosts, since
    # DNS servers respond erratically to queries for them.
    resolver {{ dns_resolver }};

    # This is used to support websocket proxying. We need to set
    # the 'Upgrade' HTTP header to either 'upgrade' (for websockets)
    # or 'close' (for everything else). See https://www.nginx.com/resources/admin-guide/reverse-proxy/
    # for more details.
    map $http_upgrade $connection_upgrade {
            default upgrade;
            ''      close;
    }

    # The shared memory area used to store route config.
    # This is shared across all workers, and stores only
    # the mapping between a route prefix and target.
    # FIXME: Make this configurable
    lua_shared_dict routes 16m;

    # This is the 'regular' server, that sees all public
    # traffic and proxies them to the appropriate backend server.
    server {
        # FIXME: Allow listening on multiple IPs (for ipv6?)
        listen {{public_ip}}:{{ public_port }};

        location / {
            # We use lua code to determine which backend this URL will go
            # to. It checks the route table (maintained by the api server{}
            # block below) from the shared lua dict, and if no route matches,
            # either sends it to the default if a default is set or 404s.

            # We declare an nginx variable here, since lua code can't set
            # variables that have not been declared
            set $upstream "";

            access_by_lua '
                local routespec = ngx.var.request_uri

                local specs = ngx.shared.routes:get_keys()

                -- FIXME: This is a O(nlogn) algorithm for routing, where we
                -- first sort the table in descending order of length and then
                -- route to the first prefix that matches. The sorting is O(nlogn)
                -- so the entire thing is O(logn). We can easily get this to O(n)
                -- and with a trie, even lower.
                table.sort(specs, function(a, b) return string.length(a) < string.length(b) end)
                for i, spec in pairs(specs) do
                    if string.sub(routespec,1,string.len(spec)) == spec then
                        ngx.var.upstream = ngx.shared.routes:get(spec)
                        return
                    end
                end
                if target == nil then
                    {% if default_target -%}
                        ngx.var.upstream = "{{default_target}}"
                    {% else -%}
                        ngx.exit(404)
                    {% endif -%}
                end
            ';

            proxy_pass $upstream;

            proxy_http_version 1.1;

            # This is required for websockets to be proxied correctly
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # This is required for the target servers to know what
            # exactly the original protocol / URI / Host was.
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Original-URI $request_uri;
            proxy_set_header Host $host:$server_port;
        }
    }

    # This is the API server, which only JupyterHub talks to.
    # This is protected by requiring an Authentication header.
    server {
        listen {{api_ip}}:{{api_port}};

        location /api/routes {
            content_by_lua '
                -- Check for an authentication token. This is shared
                -- with JupyterHub
                local reqAuth = "token {{authtoken}}"

                if ngx.var.http_AUTHORIZATION ~= reqAuth then
                    ngx.exit(403);
                end

                if ngx.req.get_method() == "POST" then
                    local cjson = require "cjson"
                    local string = require "string"

                    ngx.req.read_body()
                    local body = cjson.decode(ngx.var.request_body)
                    local target = body["target"]
                    if target == nil then
                        ngx.exit(400)
                    end

                    local routespec = string.sub(ngx.var.request_uri, 12)

                    ngx.shared.routes:set(routespec, target)
                    ngx.exit(201)
                elseif ngx.req.get_method() == "DELETE" then
                    local routespec = string.sub(ngx.var.request_uri, 12)

                    ngx.shared.routes:delete(routespec)
                elseif ngx.req.get_method() == "GET" then
                    local cjson = require "cjson"

                    local routes = {}

                    local routespecs = ngx.shared.routes:get_keys()

                    for i, spec in pairs(routespecs) do
                        routes[spec] = { target = ngx.shared.routes:get(spec) }
                    end

                    ngx.say(cjson.encode(routes))
                end

            ';
        }
    }
}
